new<-colnames(dat)[!colnames(dat)%in%colnames(output)]
output[,new]<-NA
stopifnot(all(colnames(dat)%in%colnames(output)))
}
if(any(!colnames(output)%in%colnames(dat))){
new<-colnames(output)[!colnames(output)%in%colnames(dat)]
dat[,new]<-NA
stopifnot(all(colnames(output)%in%colnames(dat)))
}
}## checking if output is not null.
if(is.null(output)==TRUE){
output<-dat
}else{
output<-dplyr::bind_rows(output,dat)
}
dat<-NULL
} #for loop
return(output)
}
zScorePatientExpression<-function(full.dn4=NULL,markers=NULL,ROIID.column=NULL){
X3<-full.dn4[,c(markers,ROIID.column)]%>%group_by(ROIID)%>%summarise_all(funs(sd))%>%data.frame
X2<-full.dn4[,c(markers,ROIID.column)]%>%group_by(ROIID)%>%summarise_all(funs(mean))%>%data.frame
###
z<-full.dn4
for(cl in unique(full.dn4$ROIID)){
for(mark in colnames(X2)[-1]){
z[which(z$ROIID==cl),which(colnames(z)==mark)]<- ( z[which(z$ROIID==cl),which(colnames(z)==mark)]-X2[which(X2$ROIID==cl),which(colnames(X2)==mark)])/(X3[which(X3$ROIID==cl),which(colnames(X3)==mark)])
}
}
return(z)
}
metaClusterPhenotype<-function(dn4=NULL,phenotype=NULL,myPheno=NULL,markers=NULL,plotPCA=FALSE,k2=15){
#myPheno is the column for the phenotype.
erik<-subset(dn4,dn4[,myPheno]==phenotype)
## subMeta holds the casePheno
dn4[,paste0(phenotype,"_subMeta")]<-NA
erik[,paste0(phenotype,"_subMeta")]<-NA
require(Rphenograph)
roiData<-as.data.frame.matrix(table(erik$ROIID,erik[,myPheno]))
for(roi in rownames(roiData)[which(roiData[,phenotype]>45)]){
myroi<-subset(erik,erik$ROIID==roi)
graph<-Rphenograph(myroi[,markers],k=45)
myroi[,paste0(phenotype,"_subMeta")]<-membership(graph[[2]])
dn4[match(myroi$uniqueLabel,dn4$uniqueLabel),paste0(phenotype,"_subMeta")]<-membership(graph[[2]])
erik[match(myroi$uniqueLabel,erik$uniqueLabel),paste0(phenotype,"_subMeta")]<-membership(graph[[2]])
}
ErikMeta=erik[,
c(markers,
"ROIID",
paste0(phenotype,"_subMeta"))] %>% group_by(ROIID,.dots=paste0(phenotype,"_subMeta")) %>%
dplyr::summarise_all(funs(median)) %>%data.frame
##Levine used k=15 for meta.
erikPheno<- Rphenograph(ErikMeta[,c(markers)], k = k2)
subphenograph_cluster_meta<- factor(membership(erikPheno[[2]]))
table(subphenograph_cluster_meta)
ErikMeta=cbind(ErikMeta, subphenograph_cluster_meta)
### plot PCA, label each case.  COO,  status.  ##
if( any(colnames(erik)== paste0(phenotype,"_subphenograph_cluster_meta"))){
erik<-erik[,which(colnames(erik)!= paste0(phenotype,"_subphenograph_cluster_meta"))]
}
myLocal=left_join(erik, ErikMeta[,c("ROIID",paste0(phenotype,"_subMeta"),"subphenograph_cluster_meta")], by = c("ROIID"))
colnames(myLocal)[which(colnames(myLocal)=="subphenograph_cluster_meta")]<-paste0(phenotype,"_subphenograph_cluster_meta")
dn4[,paste0(phenotype,"_subphenograph_cluster_meta")]<-NA
dn4[match(myLocal$uniqueLabel,dn4$uniqueLabel),paste0(phenotype,"_subphenograph_cluster_meta")]<-myLocal[,which(colnames(myLocal)==paste0(phenotype,"_subphenograph_cluster_meta"))]
plot_clustering_heatmap_wrapper(expr=ErikMeta[,c(markers)],
cell_clustering=ErikMeta[,"subphenograph_cluster_meta"],
useMedians=TRUE,
useQuantiles=FALSE,
color_clusters=NULL)
return(dn4)
}
plot_clustering_heatmap_wrapper<-function(expr=NULL,
cell_clustering=NULL, cluster_merging = NULL,useMedians=TRUE,useQuantiles=FALSE,
color_clusters=NULL){
## cluster_merging should be character merging vector of 29 or so clusters. this is input from the ANNOTATION object.  not a matched object level.
expr<-as.matrix(expr)
if(useQuantiles==TRUE){
##max min normalization
library(matrixStats)
rng <- colQuantiles(expr, probs = c(0.001, 0.999))
expr01 <- t((t(expr) - rng[, 1]) / (rng[, 2] - rng[, 1]))
expr01[expr01 < 0] <- 0
expr01[expr01 > 1] <- 1
}else{
expr01<-expr
}
if(is.null(color_clusters)==TRUE){
color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72",
"#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3",
"#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D",
"#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999",
"#aa8282", "#d4b7b7", "#8600bf", "#ba5ce3", "#808000",
"#aeae5c", "#1e90ff", "#00bfff", "#56ff0d", "#ffff00")
}
# Calculate the median expression
library(dplyr)
expr_median <- data.frame(expr, cell_clustering = cell_clustering) %>%
dplyr::group_by(cell_clustering) %>%
dplyr::summarize_all(funs(median))
if(useMedians==TRUE){
expr01_median <- data.frame(expr01, cell_clustering = cell_clustering) %>%
group_by(cell_clustering) %>%
dplyr::summarize_all(funs(median))
}else{
expr01_median <- data.frame(expr01, cell_clustering = cell_clustering) %>%
dplyr::group_by(cell_clustering) %>%
dplyr::summarize_all(funs(mean))
}
# Calculate cluster frequencies
clustering_table <- as.numeric(table(cell_clustering))
print(dim(expr_median))
# This clustering is based on the markers that were used for the main clustering
d <- dist(expr_median[, colnames(expr)], method = "euclidean")
cluster_rows <- hclust(d, method = "average")
expr_heat <- as.matrix(expr01_median[, colnames(expr01)])
rownames(expr_heat) <- expr01_median$cell_clustering
labels_row <- paste0(rownames(expr_heat), " (",
round(clustering_table / sum(clustering_table) * 100, 2), "%)")
labels_col <- colnames(expr_heat)
# Row annotation for the heatmap
annotation_row <- data.frame(cluster = factor(expr01_median$cell_clustering))
rownames(annotation_row) <- rownames(expr_heat)
color_clusters <- color_clusters[1:nlevels(annotation_row$cluster)]
names(color_clusters) <- levels(annotation_row$cluster)
annotation_colors <- list(cluster = color_clusters)
annotation_legend <- FALSE
if(!is.null(cluster_merging)){
annotation_row$cluster_merging <- factor(cluster_merging)
color_clusters <- color_clusters[1:nlevels(factor(cluster_merging))]
names(color_clusters) <- levels(factor(cluster_merging))
annotation_colors$cluster_merging <- color_clusters
annotation_legend <- TRUE
}
# Colors for the heatmap
library(RColorBrewer);library(pheatmap)
color <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(100)
pheatmap::pheatmap(expr_heat, color = color,
cluster_cols = FALSE, cluster_rows = cluster_rows,
labels_col = labels_col, labels_row = labels_row,
display_numbers = TRUE, number_color = "black",
fontsize = 10, fontsize_number = 7,
annotation_row = annotation_row, annotation_colors = annotation_colors,
annotation_legend = annotation_legend)
}
mynormalize<-function(data=NULL,percentile=NULL){
if(percentile>1){
percentile<-percentile/100
}
if(is.null(percentile)==TRUE){
minValues<-apply(data,2,min)
maxValues<-apply(data,2,max)
}else{
minValues<-apply(data,2,function(x) quantile(x,1-percentile)  )
maxValues<-apply(data,2,function(x) quantile(x,percentile)  )
}
hv2<-maxValues-minValues
dataXR<-data
stopifnot(all( colnames(data)==names(minValues)))
stopifnot(all(colnames(data)==names(maxValues)))
stopifnot(all(colnames(data)==names(hv2)))
for(j in 1:ncol(data)){
dataXR[,j]<-(data[,j]-minValues[j])/hv2[j]
}
dataXR[dataXR<0]<-0
dataXR[dataXR>1]<-1
is.nand<-apply(dataXR,2,function(x) any(is.nan(x)))
for(i in which(is.nand)){
id<- which(is.na(dataXR[,i]))
dataXR[id,i]<-0
}
is.nad<-apply(dataXR,2,function(x) any(is.na(x)))
for(i in which(is.nad)){
id<- which(is.na(dataXR[,i]))
dataXR[id,i]<-0
}
# dataXR[which(is.na(dataXR))]<-0
stopifnot(all(apply(dataXR,2,max)==1))
stopifnot(all(apply(dataXR,2,min)==0))
return(dataXR)
}
require(ggplot2)
suppressPackageStartupMessages( require(ComplexHeatmap))
suppressPackageStartupMessages( require(knitr))
suppressPackageStartupMessages( require(kableExtra))
suppressPackageStartupMessages( require(spatstat))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(magrittr))
suppressPackageStartupMessages(library(survival))
suppressPackageStartupMessages(library(Hmisc))
library(hrbrthemes)
library(data.table)
library(dtplyr)
library(parallel)
library(neighbouRhood)
library(RColorBrewer)
library(diffcyt)
library(CATALYST)
library(gridExtra)
library(magrittr)
# FIX ME: want to develop a container that can transform into something that FlowCore or diffcyt can use for phenotype analysis in an easy way.
# goal is to containerize the IMC
library(imcExperiment)
color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72",
"#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3",
"#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D",
"#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999",
"#aa8282", "#d4b7b7", "#8600bf", "#ba5ce3", "#808000",
"#aeae5c", "#1e90ff", "#00bfff", "#56ff0d", "#ffff00")
csvPath<-"~/IMC-Ranalysis/multiple-myeloma/R/Data/"
outputDir<-"~/IMC-Ranalysis/multiple-myeloma/R/MManalysis/"
annotationKeyDir<-"~/IMC-Ranalysis/multiple-myeloma/R/annotationKeys/"
## clinical sheet assembly.
## FIX ME add a clinical file.
clinicalDir<-"~/IMC-Ranalysis/multiple-myeloma/R/clinicalAnnotation/"
## protein lineage partitions.
stopifnot(dir.exists(csvPath))
#read all IMC data, drop neighborhood, and keep tsne and phenograph runs.
mm<-readPhenoCase(myPath=csvPath,dropNeighborhooodAnalysis=FALSE)
##
all(mm$uniqueLabel==paste0(mm$ImageId,"_",mm$CellId))
is.na(mm$neighbour_4_CellId15)%>%table
# complete the clinical sheet.
##write.csv(data.frame(fileID=unique(mm$ROIID),treatment=NA,age=NA,sex=NA),file='~/Documents/imageAnalysis/multiple-myeloma/R/clinicalAnnotation/clinical.key.csv')
key<-read.csv(paste0(clinicalDir,'Key.csv'))
key<-key[which(!is.na(key$ImageId)),]
## add batch information
key$batch<-'batch1'
key$batch[key$Patient.Number%in%c(7,9,10,12,14)]<-'batch2'
key$batch[key$Patient.Number%in%c(5,11)]<-'batch3'
key$ROIID<-key$Name
background<-c("Cell_191Ir_Ir191",
"Cell_193Ir_Ir193",
"Cell_104Ru_Ru104",
"Cell_120Sn_Sn120",
"Cell_127I_I127",
"Cell_131Xe_Xe131",
"Cell_133Cs_Cs133",
"Cell_138Ba_Ba138" ,
"Cell_190Os_Os190",
"Cell_208Pb_Pb208",
"Cell_80ArAr_ArAr80" )
lineage<-c("Cell_CD11b_Sm149",
"Cell_CD138_Eu151",
"Cell_CD14_Nd144",
"Cell_CD15_Dy164",
"Cell_CD163_Gd155",
"Cell_CD16_Nd146",
"Cell_CD20_Sm147",
"Cell_CD31_Dy161",
"Cell_CD3_Er170" ,
"Cell_CD4_Gd156",
"Cell_CD68_Nd150",
"Cell_CD8a_Dy162",
"Cell_FOXP3_Dy163")
induc<-c("Cell_Caspase3_Lu175",
"Cell_Granzyme_Er167",
"Cell_HLAABC_Yb172",
"Cell_HLADR_Yb174",
"Cell_HLAE_Sm152",
"Cell_Histone3_Yb171",
"Cell_IDO_Yb173" ,
"Cell_Ki67_Er168" ,
"Cell_LAG3_Eu153" ,
"Cell_MUM1_Pr141",
"Cell_NKG2A_Nd143",
"Cell_NKG2D_Nd148",
"Cell_NKp46_Er166" ,
"Cell_PD1_Ho165",
"Cell_PDL1_Tb159" ,
"Cell_Reolysin_Gd160",
"Cell_TIM3_Sm154",
"Cell_ULBP256_Yb176")
##caspase is empty blank channel.
# "Cell_Caspase_Lu175" )
morph<-c("Area",
"Eccentricity",
"Solidity",
"Extent",
"EulerNumber",
"Perimeter",
"MajorAxisLength",
"MinorAxisLength",
"Orientation",
"Percent_Touching",
"Number_Neighbors")
neighbors<-colnames(mm)[grepl("neighbour_",colnames(mm))]
netinfo<-colnames(mm)[grepl("Phenograph",colnames(mm))]
## examine marker distributions and normalization [0,1] procedures.
# mm<-mm[,!colnames(mm)%in%background]
##  containerize the data
ex<-mm[,c(lineage,induc,background)]
rownames(ex)<-mm$uniqueLabel
## FIX ME :  needa way to subset flexibly the IMC experiment.
patientData<-DataFrame(ROIID=mm$ROIID,key[match(mm$ROIID,key$ROIID),])
## misisng clinical information "30-BM17-186_s0_p2_r1_a1_ac"
id<-which(!is.na(patientData$ROIID.1))
###    colData(imc)<-patientData
##manually subset
## For CytofRUV we need Time and Event_length
ex<-ex[id,]
ex$Time<-rnorm(nrow(ex))
ex$Event_length<-rnorm(nrow(ex))
################
imc<-imcExperiment(cellIntensity=t(ex),
coordinates=mm[id,c("X_position","Y_position")],
neighborHood=mm[id,neighbors],
network=mm[id,netinfo],
distance=matrix(1,nrow=length(id),ncol=2),
morphology=mm[id,morph],
uniqueLabel=mm[id,'uniqueLabel'],
panel=c(colnames(mm[id,c(lineage,induc,background)]),"Time","Event_length"),
ROIID=mm[id,'ROIID'])
## normalize and check the settor
## add the raw and normalized expression intensity into the assays slot.
assays(imc)$raw_counts<-counts(imc)
all(counts(imc)==assays(imc)$raw_counts)
all(counts(imc)==t(ex))
##asinh normalize with co-factor of 5.
test<-asinh(t(counts(imc))/5)
test<-mynormalize(data=test,percentile=0.99)
all( apply(test,2,max)==1)
all(apply(test,2,min)==0)
logcounts(imc)<-t(test)
all(t(logcounts(imc))==test)
##arc-sinh transform with a cofactor
##using the cofactor of 5 is widely used in mass cytometry and CyTOF
cellIntensity(imc)<-t(test)
## the settor and gettor work to match.
stopifnot( all(t(cellIntensity(imc))==test))
## spatial data
head(getCoordinates(imc))
all(getCoordinates(imc)==mm[match(getLabel(imc),mm$uniqueLabel),c("X_position","Y_position")])
##neighborhood data (only checking 1-6 neighbors for QC, we have NAs.)
head(getNeighborhood(imc))
all(getNeighborhood(imc)[,1:6]==mm[match(getLabel(imc),mm$uniqueLabel),neighbors[1:6]])
##checking network access
head(getNetwork(imc))
all(getNetwork(imc)[,1]==mm[match(getLabel(imc),mm$uniqueLabel),netinfo[1]])
par(mar=c(2,2,2,2),mfrow=c(7,7))
for(i in c(lineage,induc,background)){
hist(cellIntensity(imc)[i,],xlab='Normalized intensity',main=sapply(strsplit(i,"_"),function(x)x[2]))
}
## append metadata
metadata(imc)$key<-key
## append column data to experiment.
## FIX ME: need a flexible way to drop out ROIID and subset out to match all slots.
patientData<-DataFrame(colData(imc),key[match(colData(imc)$ROIID,key$ROIID),])
colData(imc)<-patientData
exper_info<-key[,c("Name","Treatment")]
colnames(exper_info)<-c("sample_id","group_id")
marker_info<-data.frame(channel_name=sapply(strsplit(rownames(imc),"_"),function(x) x[3]),
marker_name=rownames(imc),
marker_class=c(rep("type",13),
rep("state",18),
rep("none",13)))
marker_info$metal<-substring(marker_info$channel_name,1,2)
marker_info$mass<-as.numeric(substring(marker_info$channel_name,3,nchar(marker_info$channel_nam)))
marker_info[which(marker_info$channel_name=='ArAr80'),'mass']<-80
rowData(imc)<-marker_info
### bar-code key compute the spill over.
#  bc_key<-as.data.frame.matrix(matrix(0,nrow=36,ncol=36))
# rownames(bc_key)<-colnames(bc_key)<-c("139",
#                                      "141",
#                                     "142",
#                                    "143",
#                                   "144",
#                                  "145",
#                                 "146",
#                                "147",
#                                "148",
#                               "149",
#                              "150",
#                             "151",
#                            "152",
#                           "153",
#                          "154",
#                         "155",
#                        "156",
#                       "158",
#                      "159",
#                     "160",
#                    "161",
#                   "162",
#                  "163",
#                 "164",
#                "165",
#               "166",
#              "167",
#             "168",
#            "169",
#           "170", "171", "172",
#          "173", "174", "175", "176")
#  id<-match(marker_info$mass,rownames(bc_key))
#  for(i in id){
#    bc_key[i,i]<-1
#  }
#  metadata(imc)$bc_key<-bc_key
### this is designed for CyTOF experiments.
#sce <- computeSpillmat(imc)
chs<-c(rownames(imc))
chs<-chs[!grepl("DNA",chs)]
plotScatter(imc, chs, assay = 'logcounts')
library(CytofRUV)
library(CytofRUV)
library(CATALYST)
library(flowCore)
library(ggplot2)
library(readxl)
library(ruv)
library(purrr)
library(FlowSOM)
library(SummarizedExperiment)
library(ConsensusClusterPlus)
library(SingleCellExperiment)
library(shiny)
library(shinyjs)
library(shinydashboard)
library(writexl)
library(ComplexHeatmap)
library(shinycssloaders)
## appending Time and Event_length to the rowData
rowData(imc)$channel_name[is.na(rowData(imc)$channel_name)]<-c("Time","Event_length")
## create flowSet
## batch 1 did not have FOXP3, batch 2 missing CD16 so dropping
(fsimc <- sce2fcs(imc[c(1:5,7:12,14:33,43),], split_by = "ROIID"))
#raw fcs has Time and Event_length
output_dir="~/IMC-Ranalysis/multiple-myeloma/FCS-folder/MM-FCS/"
wd_data<-file.path()
setwd(output_dir)
wd_data<-output_dir
adata with replicates.
## drops the 'none' marker
metadata_filename="Metadata.xlsx"
panel_filename="Panel.xlsx"
seed=1234
clusters_nb=20
## Loading the data
data=load_data(wd_data,metadata_filename,panel_filename)
## Cluster the data
data$daf=cluster_data(data$daf,seed,markers_to_use=data$lineage_markers,clusters_nb)
#dir_name_norm_data = get_directory()
dir_name_norm_data="CytofRUV_Norm_data_MM"
raw_data <- data.frame(sample = data$daf$sample_id, cluster=cluster_ids(data$daf,"meta20"), t(SummarizedExperiment::assay(data$daf,"exprs")))
colnames(raw_data) <- gsub("^X", "",  colnames(raw_data))
## using the replicate samples from the multiple ROI.
#rep_samples=list(as.character(data$md[which(data$md$replicate!='r1'),'sample_id']%$%sample_id))
rep_samples=list(as.character(data$md[which(data$md$batch==3| data$md$batch==2),'sample_id']%$%sample_id))
#normalise data:
#1: residual plot: for each rep_samples selected, and for each cluster formed, identifies the residual (deviance) from each cell in rep_samples to the average per cluster
# the resmat is a matrix, for each rep_sample cells, the difference between the cluster average for those replicates.
#2: uses these in RUVIII
#20 meta-clusters defined originally
cluster_list_rep_samples <- list(seq(1,20))
k_value <- 8
seed=1234
normalise_data(data=data,
raw_data=raw_data,
rep_samples=rep_samples,
norm_clusters=cluster_list_rep_samples,
k=k_value,
num_clusters=clusters_nb,
wd_data=wd_data,
dir_norm_data=dir_name_norm_data)
wd_norm=file.path(wd_data,dir_name_norm_data)
metadata_norm_filename="Norm_Metadata.xlsx"
panel_norm_filename="Norm_Panel.xlsx"
seed=1234
clusters_nb=40
## Loading the data
norm_data=load_data(wd_norm,
metadata_norm_filename,
panel_norm_filename,
cofactor = 5)
## Cluster the data
norm_data$daf=cluster_data(norm_data$daf,seed,markers_to_use=norm_data$lineage_markers,clusters_nb)
## apply the Shiny App.
daf=norm_data$daf
md=norm_data$md
seed=1234
# Number of cells for diagnostic plots marker specific
n_subset_marker_specific <- 10000
# Define type of markers
daf_type <- daf[SingleCellExperiment::rowData(daf)$marker_class=="type", ]
daf_state <- daf[SingleCellExperiment::rowData(daf)$marker_class=="state", ]
sub_daf_state <- daf_state[, sample(ncol(daf_state), n_subset_marker_specific)]
sub_daf_type <- daf_type[, sample(ncol(daf_type), n_subset_marker_specific)]
# Define batch
batch_ids <- is.factor(rep(md$batch, nrow(daf)))
sampleID_sorted <- md$sample_id[order(md$patient_id)]
plot_clustering_heatmap_wrapper(expr=t(assay(daf,'exprs')),
cell_clustering=cluster_ids(data$daf,"meta20"),
useMedians=TRUE,
useQuantiles=FALSE,
color_clusters=NULL)
norm_data
set.seed(seed)
# Number of cells for tSNE plots marker specific
TSNE_subset <- 1000
print("Running TSNE")
daf <- runDR(daf, "TSNE", cells = TSNE_subset)
# Number of cells for UMAP plots marker specific
UMAP_subset <- 1500
print("Running UMAP")
daf <- runDR(daf, "UMAP", cells = UMAP_subset)
# Launch Shiny
# For a subset of the data, define the number of cells for diagnostic plots
n_subset <- 1500
sub_daf <- daf[, sample(ncol(daf), n_subset)]
# # For the full dataset:
# sub_daf <- daf
panel=data$panel
CytofRUV::launch_Shiny(daf)
