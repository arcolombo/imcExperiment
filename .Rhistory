"Cell_CD206",
"Cell_CD3",
"Cell_CD30",
"Cell_CD31",
"Cell_CD4",
"Cell_CD45RA",
"Cell_CD45RO",
"Cell_CD68" ,
"Cell_CD8",
"Cell_EphrinB2",
"Cell_FOXP3",
"Cell_HLADR" )
induc<-c("Cell_C",
"Cell_CCR4",
"Cell_CD134",
"Cell_CXCR3",
"Cell_Granzym",
"Cell_ICOS",
"Cell_Ki67",
"Cell_Lag3",
"Cell_PD1",
"Cell_PDL1",
"Cell_PDL2",
"Cell_Tbet",
"Cell_Tim3",
"Cell_Vimentin",
"Cell_Vista",
"Cell_p",
"Cell_DNA",
"Cell_DNA2")
myl<-list(hd.lineage,
hd.induc,
lineage_markers,
induc)
names(myl)<-c("hd.lineage","hd.induc","lineage_markers","induc")
return(myl)
}
color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72",
"#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3",
"#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D",
"#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999",
"#aa8282", "#d4b7b7", "#8600bf", "#ba5ce3", "#808000",
"#aeae5c", "#1e90ff", "#00bfff", "#56ff0d", "#ffff00")
mynormalize<-function(data=NULL,percentile=NULL){
if(percentile>1){
percentile<-percentile/100
}
if(is.null(percentile)==TRUE){
minValues<-apply(data,2,min)
maxValues<-apply(data,2,max)
}else{
minValues<-apply(data,2,function(x) quantile(x,1-percentile)  )
maxValues<-apply(data,2,function(x) quantile(x,percentile)  )
}
hv2<-maxValues-minValues
dataXR<-data
stopifnot(all( colnames(data)==names(minValues)))
stopifnot(all(colnames(data)==names(maxValues)))
stopifnot(all(colnames(data)==names(hv2)))
for(j in 1:ncol(data)){
dataXR[,j]<-(data[,j]-minValues[j])/hv2[j]
}
dataXR[dataXR<0]<-0
dataXR[dataXR>1]<-1
is.nand<-apply(dataXR,2,function(x) any(is.nan(x)))
for(i in which(is.nand)){
id<- which(is.na(dataXR[,i]))
dataXR[id,i]<-0
}
is.nad<-apply(dataXR,2,function(x) any(is.na(x)))
for(i in which(is.nad)){
id<- which(is.na(dataXR[,i]))
dataXR[id,i]<-0
}
# dataXR[which(is.na(dataXR))]<-0
stopifnot(all(apply(dataXR,2,max)==1))
stopifnot(all(apply(dataXR,2,min)==0))
return(dataXR)
}
knitr::opts_chunk$set(echo = TRUE)
# this function reads CSV from histoCAT and creates an Robject of the spatial features
## FIXME: need a parameter for neighbour_ features, tSNE features, and Phenograph features.
readPhenoCase<-function(myPath=NULL,dropNeighborhooodAnalysis=TRUE){
# myPath is the directory to the histoCAT output csv files
#
output<-NULL
targs<-unique(dir(myPath))
for(i in targs){
print(i)
dat<-read.csv(paste0(myPath,"/",i))
if( any(grepl("Phenograph",colnames(dat)))==TRUE){
phenos<-colnames(dat)[grepl("Phenograph",colnames(dat))]
newphenoID<-unique(phenos)
}else{
dat[,'Phenograph']<-NA
}
if( any(grepl("tSNE",colnames(dat)))==TRUE){
tsnes<-colnames(dat)[grepl("tSNE",colnames(dat))]
newtsneID<-unique(tsnes)
}else{
dat[,'tSNE']<-NA
}
#if drop is true ignore neighbour_ columns, otherwise keep.
if(dropNeighborhooodAnalysis==TRUE){
mycolumns<-c("ImageId","CellId",
"Area",
"Eccentricity",
"Solidity",
"Extent",
"EulerNumber",
"Perimeter",
"MajorAxisLength",
"MinorAxisLength",
"Orientation",
"Percent_Touching",
"Number_Neighbors",
"X_position",
"Y_position",
newphenoID,
newtsneID)
}else{
nbhds<-colnames(dat)[grepl("neighbour_",colnames(dat))]
neighborID<-unique(nbhds)
mycolumns<-c("ImageId",
"CellId",
"Area",
"Eccentricity",
"Solidity",
"Extent",
"EulerNumber",
"Perimeter",
"MajorAxisLength",
"MinorAxisLength",
"Orientation",
"Percent_Touching",
"Number_Neighbors",
"X_position",
"Y_position",
newphenoID,
newtsneID,
neighborID)
}
markers<-colnames(dat)[grepl("Cell_",colnames(dat))]
myColumns<-c(mycolumns,markers)
dat<-dat[,myColumns]
dat$ROIID<- gsub(".csv","",i)
dat$uniqueLabel<-paste0(dat$ImageId,"_",dat$CellId)
### if there are columns in a specific case that do not match the previous calls, usually from histoCAT analysis.
if(!is.null(output)==TRUE){
if(any(!colnames(dat)%in%colnames(output))){
new<-colnames(dat)[!colnames(dat)%in%colnames(output)]
output[,new]<-NA
stopifnot(all(colnames(dat)%in%colnames(output)))
}
if(any(!colnames(output)%in%colnames(dat))){
new<-colnames(output)[!colnames(output)%in%colnames(dat)]
dat[,new]<-NA
stopifnot(all(colnames(output)%in%colnames(dat)))
}
}## checking if output is not null.
if(is.null(output)==TRUE){
output<-dat
}else{
output<-dplyr::bind_rows(output,dat)
}
dat<-NULL
} #for loop
return(output)
}
zScorePatientExpression<-function(full.dn4=NULL,markers=NULL,ROIID.column=NULL){
X3<-full.dn4[,c(markers,ROIID.column)]%>%group_by(ROIID)%>%summarise_all(funs(sd))%>%data.frame
X2<-full.dn4[,c(markers,ROIID.column)]%>%group_by(ROIID)%>%summarise_all(funs(mean))%>%data.frame
###
z<-full.dn4
for(cl in unique(full.dn4$ROIID)){
for(mark in colnames(X2)[-1]){
z[which(z$ROIID==cl),which(colnames(z)==mark)]<- ( z[which(z$ROIID==cl),which(colnames(z)==mark)]-X2[which(X2$ROIID==cl),which(colnames(X2)==mark)])/(X3[which(X3$ROIID==cl),which(colnames(X3)==mark)])
}
}
return(z)
}
metaClusterPhenotype<-function(dn4=NULL,phenotype=NULL,myPheno=NULL,markers=NULL,plotPCA=FALSE,k2=15){
#myPheno is the column for the phenotype.
erik<-subset(dn4,dn4[,myPheno]==phenotype)
## subMeta holds the casePheno
dn4[,paste0(phenotype,"_subMeta")]<-NA
erik[,paste0(phenotype,"_subMeta")]<-NA
require(Rphenograph)
roiData<-as.data.frame.matrix(table(erik$ROIID,erik[,myPheno]))
for(roi in rownames(roiData)[which(roiData[,phenotype]>45)]){
myroi<-subset(erik,erik$ROIID==roi)
graph<-Rphenograph(myroi[,markers],k=45)
myroi[,paste0(phenotype,"_subMeta")]<-membership(graph[[2]])
dn4[match(myroi$uniqueLabel,dn4$uniqueLabel),paste0(phenotype,"_subMeta")]<-membership(graph[[2]])
erik[match(myroi$uniqueLabel,erik$uniqueLabel),paste0(phenotype,"_subMeta")]<-membership(graph[[2]])
}
ErikMeta=erik[,
c(markers,
"ROIID",
paste0(phenotype,"_subMeta"))] %>% group_by(ROIID,.dots=paste0(phenotype,"_subMeta")) %>%
dplyr::summarise_all(funs(median)) %>%data.frame
##Levine used k=15 for meta.
erikPheno<- Rphenograph(ErikMeta[,c(markers)], k = k2)
subphenograph_cluster_meta<- factor(membership(erikPheno[[2]]))
table(subphenograph_cluster_meta)
ErikMeta=cbind(ErikMeta, subphenograph_cluster_meta)
### plot PCA, label each case.  COO,  status.  ##
if( any(colnames(erik)== paste0(phenotype,"_subphenograph_cluster_meta"))){
erik<-erik[,which(colnames(erik)!= paste0(phenotype,"_subphenograph_cluster_meta"))]
}
myLocal=left_join(erik, ErikMeta[,c("ROIID",paste0(phenotype,"_subMeta"),"subphenograph_cluster_meta")], by = c("ROIID"))
colnames(myLocal)[which(colnames(myLocal)=="subphenograph_cluster_meta")]<-paste0(phenotype,"_subphenograph_cluster_meta")
dn4[,paste0(phenotype,"_subphenograph_cluster_meta")]<-NA
dn4[match(myLocal$uniqueLabel,dn4$uniqueLabel),paste0(phenotype,"_subphenograph_cluster_meta")]<-myLocal[,which(colnames(myLocal)==paste0(phenotype,"_subphenograph_cluster_meta"))]
plot_clustering_heatmap_wrapper(expr=ErikMeta[,c(markers)],
cell_clustering=ErikMeta[,"subphenograph_cluster_meta"],
useMedians=TRUE,
useQuantiles=FALSE,
color_clusters=NULL)
return(dn4)
}
plot_clustering_heatmap_wrapper<-function(expr=NULL,
cell_clustering=NULL, cluster_merging = NULL,useMedians=TRUE,useQuantiles=FALSE,
color_clusters=NULL){
## cluster_merging should be character merging vector of 29 or so clusters. this is input from the ANNOTATION object.  not a matched object level.
expr<-as.matrix(expr)
if(useQuantiles==TRUE){
##max min normalization
library(matrixStats)
rng <- colQuantiles(expr, probs = c(0.001, 0.999))
expr01 <- t((t(expr) - rng[, 1]) / (rng[, 2] - rng[, 1]))
expr01[expr01 < 0] <- 0
expr01[expr01 > 1] <- 1
}else{
expr01<-expr
}
if(is.null(color_clusters)==TRUE){
color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72",
"#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3",
"#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D",
"#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999",
"#aa8282", "#d4b7b7", "#8600bf", "#ba5ce3", "#808000",
"#aeae5c", "#1e90ff", "#00bfff", "#56ff0d", "#ffff00")
}
# Calculate the median expression
library(dplyr)
expr_median <- data.frame(expr, cell_clustering = cell_clustering) %>%
dplyr::group_by(cell_clustering) %>%
dplyr::summarize_all(funs(median))
if(useMedians==TRUE){
expr01_median <- data.frame(expr01, cell_clustering = cell_clustering) %>%
group_by(cell_clustering) %>%
dplyr::summarize_all(funs(median))
}else{
expr01_median <- data.frame(expr01, cell_clustering = cell_clustering) %>%
dplyr::group_by(cell_clustering) %>%
dplyr::summarize_all(funs(mean))
}
# Calculate cluster frequencies
clustering_table <- as.numeric(table(cell_clustering))
print(dim(expr_median))
# This clustering is based on the markers that were used for the main clustering
d <- dist(expr_median[, colnames(expr)], method = "euclidean")
cluster_rows <- hclust(d, method = "average")
expr_heat <- as.matrix(expr01_median[, colnames(expr01)])
rownames(expr_heat) <- expr01_median$cell_clustering
labels_row <- paste0(rownames(expr_heat), " (",
round(clustering_table / sum(clustering_table) * 100, 2), "%)")
labels_col <- colnames(expr_heat)
# Row annotation for the heatmap
annotation_row <- data.frame(cluster = factor(expr01_median$cell_clustering))
rownames(annotation_row) <- rownames(expr_heat)
color_clusters <- color_clusters[1:nlevels(annotation_row$cluster)]
names(color_clusters) <- levels(annotation_row$cluster)
annotation_colors <- list(cluster = color_clusters)
annotation_legend <- FALSE
if(!is.null(cluster_merging)){
annotation_row$cluster_merging <- factor(cluster_merging)
color_clusters <- color_clusters[1:nlevels(factor(cluster_merging))]
names(color_clusters) <- levels(factor(cluster_merging))
annotation_colors$cluster_merging <- color_clusters
annotation_legend <- TRUE
}
# Colors for the heatmap
library(RColorBrewer);library(pheatmap)
color <- colorRampPalette(rev(brewer.pal(n = 9, name = "RdYlBu")))(100)
pheatmap::pheatmap(expr_heat, color = color,
cluster_cols = FALSE, cluster_rows = cluster_rows,
labels_col = labels_col, labels_row = labels_row,
display_numbers = TRUE, number_color = "black",
fontsize = 10, fontsize_number = 7,
annotation_row = annotation_row, annotation_colors = annotation_colors,
annotation_legend = annotation_legend)
}
mynormalize<-function(data=NULL,percentile=NULL){
if(percentile>1){
percentile<-percentile/100
}
if(is.null(percentile)==TRUE){
minValues<-apply(data,2,min)
maxValues<-apply(data,2,max)
}else{
minValues<-apply(data,2,function(x) quantile(x,1-percentile)  )
maxValues<-apply(data,2,function(x) quantile(x,percentile)  )
}
hv2<-maxValues-minValues
dataXR<-data
stopifnot(all( colnames(data)==names(minValues)))
stopifnot(all(colnames(data)==names(maxValues)))
stopifnot(all(colnames(data)==names(hv2)))
for(j in 1:ncol(data)){
dataXR[,j]<-(data[,j]-minValues[j])/hv2[j]
}
dataXR[dataXR<0]<-0
dataXR[dataXR>1]<-1
is.nand<-apply(dataXR,2,function(x) any(is.nan(x)))
for(i in which(is.nand)){
id<- which(is.na(dataXR[,i]))
dataXR[id,i]<-0
}
is.nad<-apply(dataXR,2,function(x) any(is.na(x)))
for(i in which(is.nad)){
id<- which(is.na(dataXR[,i]))
dataXR[id,i]<-0
}
# dataXR[which(is.na(dataXR))]<-0
stopifnot(all(apply(dataXR,2,max)==1))
stopifnot(all(apply(dataXR,2,min)==0))
return(dataXR)
}
metaClusterIMC<-function(imc=NULL,markers=NULL,plotPCA=FALSE,k2=15){
#imc is the container, must have normcounts assigned.
##markers: the markers to use for clustering.
require(Rphenograph)
roiData<-unique(colData(imc)$ROIID)
Graph<-NULL
for(roi in roiData){
myroi<-subsetCase(imc,roi)
minmax<-t(normcounts(myroi))
graph<-Rphenograph(minmax[,markers],k=45)
graph.out<-data.frame(id=getLabel(myroi),cluster=as.numeric(membership(graph[[2]])))
Graph<-rbind(Graph,graph.out)
}
fullExpr=as.data.frame(t(normcounts(imc)))
fullExpr$ROIID<-colData(imc)$ROIID
fullExpr$Roicluster<-Graph$cluster[match(rownames(fullExpr),Graph$id)]
fullExpr$uniqueLabel<-getLabel(imc)
ErikMeta<-fullExpr[,c(markers,"ROIID","Roicluster")] %>% group_by(ROIID,Roicluster) %>%
dplyr::summarise_all(funs(median)) %>%data.frame
##Levine used k=15 for meta.
erikPheno<- Rphenograph(ErikMeta[,c(markers)], k = k2)
subphenograph_cluster_meta<- factor(membership(erikPheno[[2]]))
table(subphenograph_cluster_meta)
ErikMeta=cbind(ErikMeta, subphenograph_cluster_meta)
### plot PCA, label each case.  COO,  status.  ##
myLocal=left_join(fullExpr, ErikMeta[,c("ROIID","Roicluster","subphenograph_cluster_meta")], by = c("ROIID","Roicluster"))
rownames(myLocal)<-rownames(fullExpr)
##assign back to Imc container.
fullNet<-as.data.frame(getNetwork(imc))
fullNet[,"ROILevelCluster"]<-NA
fullNet[,"metaCluster"]<-NA
rownames(fullNet)<-getLabel(imc)
fullNet[match(myLocal$uniqueLabel,rownames(fullNet)),"ROILevelCluster"]<-myLocal[,which(colnames(myLocal)=="Roicluster")]
fullNet[match(myLocal$uniqueLabel,rownames(fullNet)),"metaCluster"]<-myLocal[,which(colnames(myLocal)=="subphenograph_cluster_meta")]
getNetwork(imc)<-fullNet
plot_clustering_heatmap_wrapper(expr=ErikMeta[,c(markers)],
cell_clustering=ErikMeta[,"subphenograph_cluster_meta"],
useMedians=TRUE,
useQuantiles=FALSE,
color_clusters=NULL)
return(imc)
}
###experimental drafting of sub-phenotyping the IMC
metaClusterPhenotypeIMC<-function(imc=NULL,phenotype=NULL,myPheno=NULL,markers=NULL,plotPCA=FALSE,k2=15){
#myPheno is the column for the phenotype.
pheno.id<-which(getNetwork(imc)[,myPheno]==phenotype)
dn4<-as.data.frame(t(normcounts(imc)))
dn4$uniqueLabel<-getLabel(imc)
erik<-dn4[pheno.id,]
## subMeta holds the casePheno
dn4[,"label_subMeta"]<-NA
erik[,"label_subMeta"]<-NA
erik$ROIID<-colData(imc)$ROIID[pheno.id]
erik$label<-getNetwork(imc)[pheno.id,myPheno]
require(Rphenograph)
roiData<-roiData<-as.data.frame.matrix(table(erik$ROIID,erik[,"label"]))
for(roi in rownames(roiData)[which(roiData[,phenotype]>35)]){
print(roi)
myroi<-subset(erik,erik$ROIID==roi)
graph<-Rphenograph(myroi[,markers],k=35)
myroi[,"label_subMeta"]<-membership(graph[[2]])
dn4[match(myroi$uniqueLabel,dn4$uniqueLabel),"label_subMeta"]<-membership(graph[[2]])
erik[match(myroi$uniqueLabel,erik$uniqueLabel),"label_subMeta"]<-membership(graph[[2]])
}
ErikMeta=erik[,
c(markers,
"ROIID",
"label_subMeta")] %>% group_by(ROIID,"label_subMeta") %>%
dplyr::summarise_all(funs(median)) %>%data.frame
##Levine used k=15 for meta.
erikPheno<- Rphenograph(ErikMeta[,c(markers)], k = k2)
subphenograph_cluster_meta<- factor(membership(erikPheno[[2]]))
table(subphenograph_cluster_meta)
ErikMeta=cbind(ErikMeta, subphenograph_cluster_meta)
### plot PCA, label each case.  COO,  status.  ##
if( any(colnames(erik)== "subphenograph_cluster_meta")){
erik<-erik[,which(colnames(erik)!="subphenograph_cluster_meta")]
}
myLocal=left_join(erik, ErikMeta[,c("ROIID","label_subMeta","subphenograph_cluster_meta")], by = c("ROIID","label_subMeta"))
dn4[,"subphenograph_cluster_meta"]<-NA
dn4[match(myLocal$uniqueLabel,dn4$uniqueLabel),"subphenograph_cluster_meta"]<-myLocal[,which(colnames(myLocal)=="subphenograph_cluster_meta")]
nets<-getNetwork(imc)
nets$uniqueLabel<-getLabel(imc)
nets[match(myLocal$uniqueLabel,nets$uniqueLabel),"subphenograph_cluster_meta"]<-paste0(phenotype,"_",myLocal[,which(colnames(myLocal)=="subphenograph_cluster_meta")])
return(imc)
}
identifySubPopulationsIMC<-function(imc=imc,induc=NULL,lineage=NULL,morphologyMarkers=NULL,UseMorphology=TRUE,myLabel="label"){
full.dn4<-as.data.frame(t(normcounts(imc)))
full.dn4$cell.type.new<-getNetwork(imc)[,myLabel]
full.dn4$subType<-as.character(full.dn4$cell.type.new)
full.dn4$subType.correction<-as.character(full.dn4$cell.type.new)
full.dn4$subType.reassignedLabel<-as.character(full.dn4$subType)
full.dn4$uniqueLabel<-getLabel(imc)
if(UseMorphology){
morphs<-getMorphology(imc12)
full.dn4<-cbind(full.dn4,morphs)
morph<-morphologyMarkers
}else{
morph<-NULL
}
for(i in unique(as.character(full.dn4$cell.type.new))){
ROI=data.frame(subset(full.dn4,full.dn4$subType==i))
set.seed(42)
graph<- Rphenograph(ROI[,c(lineage,induc,morph)], k = 50)
phenograph_cluster<- factor(membership(graph[[2]]))
full.dn4$subType[match(ROI$uniqueLabel,full.dn4$uniqueLabel)]=paste0(i,"_",phenograph_cluster)
}
fullNet<-getNetwork(imc)
fullNet$uniqueLabel<-getLabel(imc)
fullNet$subtype[match(full.dn4$uniqueLabel,fullNet$uniqueLabel)]<-full.dn4$subType
getNetwork(imc)<-fullNet
return(imc)
}
require(ggplot2)
suppressPackageStartupMessages( require(ComplexHeatmap))
suppressPackageStartupMessages( require(knitr))
suppressPackageStartupMessages( require(kableExtra))
suppressPackageStartupMessages( require(spatstat))
suppressPackageStartupMessages(library(dplyr))
suppressPackageStartupMessages(library(magrittr))
suppressPackageStartupMessages(library(survival))
suppressPackageStartupMessages(library(Hmisc))
library(hrbrthemes)
library(data.table)
library(dtplyr)
library(parallel)
library(neighbouRhood)
library(RColorBrewer)
library(diffcyt)
library(CATALYST)
library(gridExtra)
library(magrittr)
# FIX ME: want to develop a container that can transform into something that FlowCore or diffcyt can use for phenotype analysis in an easy way.
# goal is to containerize the IMC
library(imcExperiment)
color_clusters <- c("#DC050C", "#FB8072", "#1965B0", "#7BAFDE", "#882E72",
"#B17BA6", "#FF7F00", "#FDB462", "#E7298A", "#E78AC3",
"#33A02C", "#B2DF8A", "#55A1B1", "#8DD3C7", "#A6761D",
"#E6AB02", "#7570B3", "#BEAED4", "#666666", "#999999",
"#aa8282", "#d4b7b7", "#8600bf", "#ba5ce3", "#808000",
"#aeae5c", "#1e90ff", "#00bfff", "#56ff0d", "#ffff00")
csvPath<-"~/IMC-Ranalysis/multiple-myeloma/R/Data/"
outputDir<-"~/IMC-Ranalysis/multiple-myeloma/R/MManalysis/"
annotationKeyDir<-"~/IMC-Ranalysis/multiple-myeloma/R/annotationKeys/"
## clinical sheet assembly.
## FIX ME add a clinical file.
clinicalDir<-"~/IMC-Ranalysis/multiple-myeloma/R/clinicalAnnotation/"
## protein lineage partitions.
stopifnot(dir.exists(csvPath))
#read all IMC data, drop neighborhood, and keep tsne and phenograph runs.
mm<-readPhenoCase(myPath=csvPath,dropNeighborhooodAnalysis=FALSE)
##
all(mm$uniqueLabel==paste0(mm$ImageId,"_",mm$CellId))
is.na(mm$neighbour_4_CellId15)%>%table
# complete the clinical sheet.
##write.csv(data.frame(fileID=unique(mm$ROIID),treatment=NA,age=NA,sex=NA),file='~/Documents/imageAnalysis/multiple-myeloma/R/clinicalAnnotation/clinical.key.csv')
key<-read.csv(paste0(clinicalDir,'Key.csv'))
key<-key[which(!is.na(key$ImageId)),]
## add batch information
key$batch<-'batch1'
key$batch[key$Patient.Number%in%c(7,9,10,12,14)]<-'batch2'
key$batch[key$Patient.Number%in%c(5,11)]<-'batch3'
key$ROIID<-key$Name
library(imcExperiment)
rexp
rexp(100,rate=5)
rexp(100,rate=1/5)
devtools::document()
devtools::build_manual()
Sys.getenv("R_ENVIRON")
Sys.getenv("R_HOME")
sys.getenv("PATH")
Sys.getenv("PATH")
Sys.getenv("PATH")
Sys.which("pdflatex")
Sys.which("rtools")
Sys.which("rtools40")
Sys.which("rtools")
Sys.which("Rtools")
Sys.getenv("PATH")
Sys.which("rtools40")
devtools::build_manual()
