---
title: "imcExperiment: Applications and Beyond"
author: "Anthony Colombo"
output: 
  html_vignette:
  toc: true
  number_sections: true
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteIndexEntry{imcExperiment: containerization of IMC data}
  \usepackage[utf8]{inputenc}   
date: "`r format(Sys.time(), '%d %B, %Y')`"
---


 
# Introduction
High-dimensional imaging mass cytometry utilizes multiplexed staining of cell lineage and state in-situ allowing for the interrogation of cellular population characterization and patterns of spatial phenomena.  Here we present an R-based workflow analysis which organizes imaging mass cytometry data into formalized data structure allowing for connections to established BioConductor pipelines utilized for abundance/state differential testing and spatial analysis.  Analysis pipelines utilized developed for mass cytometry, which identifies cell populations and differential testing, can be utilized by imaging mass cytometry.  The Geographic Information Systems libraries can also be utilized for the analysis of spatial point patterns.  


# Introduction
- software overview: Preprocessing R workflows such as cytofRUV (CITE), CATALYST (CITE), opeCyto(CITE) could be used to examine marker intensity, normalization, and sample variation.
-The histoCAT software allows for preliminary exploratory cluster analysis and has high quality visual capabilities that allow for the examination of the segmentation mask overlaid with the raw tissue marker intensity as an important quality control step. For customized cluster analysis, alternative clustering algorithms such as FlowSOM (CITE) and differential testing using diffCyt (CITE), a local analysis can be performed.  
- motivation and aim: 

# Reproducibility

# Data description
We subset an experiment originating from an imaging mass cytometry (IMC) experiment of tissues related to the bone-marrow.  The experimental panel was performed with 45 different markers in two different experimental batches which contain several lineage, state and background markers.  The experimental tissues were stained and ablated using Fluidigm protocols, and image processing and segmentation was performed using CellProfiler/Ilastik workflows (CITE).  This experiment contained 14 subjects of which contained at most 6 replicate regions of interest per participant.

-batch definition: had experimental set up with 2 batches containing experimental marker staining.
-TMA: The tissues were obtained from 3 different tumor micro-arrays from bone-marrow tissues and CLOT (?) tissue types
-covariates: age, cytogenetics were obtained

data columns: The initial data was retrieved from the output of CellProfiler and input into histoCAT using Bodennmiller (CITE) pipelines.  The CellProfiler segmentation processed generated features such as cellular area, eccentricity, solidity, extent, Euler number, perimeter and major/minor axis lengths, percent touching, and orientation.  Additional columns such as neighbor ID utilized histoCAT (CITE) default parameter setting which identifies the cell ID of up to 15 neighbors within 8 microns of a given cell.  The panel included 16 lineage markers, 15 'state' markers, and 11 background markers.

-condition: treatment condition (pre/post)


# Data import
 The data generated by either histoCAT or CellProfiler are most compatible with this S4 container, because we utilized the SingleCellExperiment class structure but append customized slots for features generated by histoCAT and CellProfiler.  
 The data output from these softwares have been compiled into a data frame which contain clinical features (age, cytogenetic), the important columns for organizing the data into the container should include the following columns:
 * ROIID: the region of interest
 * sample id: the primary participant ID of which replicates (if any) were obtained.
 * unique cell ID label: we recommend providing unique labels to each cell type.
 * coordinate information: the output from CellProfiler creates columns for spatial positions titled "X_position", "Y_position", which is required for the S4 class.
 * sample id, condition treatment and patient id are required columns.
 
 * FIX ME: alternative data imports using Excel sheets, and software for those data types.


## Cell-population analysis {.tabset} 
```{r}



 metaClusterIMC<-function(imc=NULL,markers=NULL,plotPCA=FALSE,k2=15,assay="exprs"){
 #imc is the container, must have normcounts assigned.
  ##markers: the markers to use for clustering.
    
 require(Rphenograph);require(igraph);require(dplyr)
   roiData<-unique(colData(imc)$ROIID)
   Graph<-NULL
   for(roi in roiData){
     myroi<-subsetCase(imc,roi)
     minmax<-t(assays(myroi)[[assay]])
     graph<-Rphenograph(minmax[,markers],k=45)
     graph.out<-data.frame(id=getLabel(myroi),cluster=as.numeric(membership(graph[[2]])))
     Graph<-rbind(Graph,graph.out)
   }
   
  fullExpr=as.data.frame(t(assays(imc)[[assay]]))
  fullExpr$ROIID<-colData(imc)$ROIID
  fullExpr$Roicluster<-Graph$cluster[match(rownames(fullExpr),Graph$id)]
  fullExpr$uniqueLabel<-getLabel(imc)
   ErikMeta<-fullExpr[,c(markers,"ROIID","Roicluster")] %>% group_by(ROIID,Roicluster) %>% 
       dplyr::summarise_all(funs(median)) %>%data.frame
     
          ##Levine used k=15 for meta.
     erikPheno<- Rphenograph(ErikMeta[,c(markers)], k = k2)
     subphenograph_cluster_meta<- factor(membership(erikPheno[[2]]))
     table(subphenograph_cluster_meta)
     ErikMeta=cbind(ErikMeta, subphenograph_cluster_meta)
     ### plot PCA, label each case.  COO,  status.  ## 
   
   myLocal=left_join(fullExpr, ErikMeta[,c("ROIID","Roicluster","subphenograph_cluster_meta")], by = c("ROIID","Roicluster"))
   rownames(myLocal)<-rownames(fullExpr)
  
   ##assign back to Imc container.
  fullNet<-as.data.frame(getNetwork(imc))
  fullNet[,"ROILevelCluster"]<-NA
  fullNet[,"metaCluster"]<-NA
  rownames(fullNet)<-getLabel(imc)
   fullNet[match(myLocal$uniqueLabel,rownames(fullNet)),"ROILevelCluster"]<-myLocal[,which(colnames(myLocal)=="Roicluster")]
  fullNet[match(myLocal$uniqueLabel,rownames(fullNet)),"metaCluster"]<-myLocal[,which(colnames(myLocal)=="subphenograph_cluster_meta")]

  getNetwork(imc)<-fullNet
   return(imc)
  }  


```
### Containerize histoCAT or CellProfiler Output Data
- min/max normalization cite Michael Angelo (CITE)
- data organization: define condition, sample id, ROIID
- cast into a flowSet for diagnostic analyses.
- IMC constructor uses the raw intensity output from software into the slot **cellIntensity**, but under the assays list we include the scaled counts for heat map and plotting.
```{r,message=FALSE}
 library(imcExperiment)
 data("pre")
 
	
	lineage<-c("Cell_CD11b_Sm149",
		"Cell_CD138_Eu151",
	        "Cell_CD14_Nd144",
                "Cell_CD15_Dy164",
                "Cell_CD163_Gd155",
	        "Cell_CD16_Nd146",
                "Cell_CD20_Sm147",
                "Cell_CD31_Dy161",
	        "Cell_CD3_Er170" ,
                "Cell_CD4_Gd156",
                "Cell_CD68_Nd150",
          	"Cell_CD8a_Dy162",
	        "Cell_FOXP3_Dy163",
		 "Cell_NKG2A_Nd143",
           "Cell_NKG2D_Nd148",
           "Cell_NKp46_Er166")
	
	
  induc<-c("Cell_Caspase3_Lu175",
	   "Cell_Granzyme_Er167",
	   "Cell_HLAABC_Yb172",
	   "Cell_HLADR_Yb174",
	   "Cell_HLAE_Sm152",
           "Cell_Histone3_Yb171",
           "Cell_IDO_Yb173" ,
	   "Cell_Ki67_Er168" ,
           "Cell_LAG3_Eu153" ,
           "Cell_MUM1_Pr141",
           "Cell_PD1_Ho165",
           "Cell_PDL1_Tb159" ,
           "Cell_TreatmentDrug_Gd160",
           "Cell_TIM3_Sm154",
           "Cell_ULBP256_Yb176")
   ##caspase is empty blank channel.
          # "Cell_Caspase_Lu175" )
  background<-c("Cell_191Ir_Ir191",
		"Cell_193Ir_Ir193")
		
 	morph<-c("Area",
	"Eccentricity",
	"Solidity",
	"Extent",
	"EulerNumber",
	"Perimeter",
	"MajorAxisLength",
	"MinorAxisLength",
	"Orientation",
	"Percent_Touching",
	"Number_Neighbors")

  
  ##ob
 expr<-pre[,c(lineage,induc,background)]
  normExp<-percentilenormalize(data=expr,percentile=0.99)
  normExp<-as.matrix(normExp)


  ##spatial component
  spatial<-(pre[,c("X_position","Y_position")])
  spatial<-as.matrix(spatial)
 ##uniqueLabel
  uniqueLabel<-paste0(pre[,"ImageId"],"_",pre[,"CellId"])

 phenotypes<-pre[,grepl("Phenograph",colnames(pre))]
 morph<-as.matrix(pre[,c("Area","Eccentricity",
	"Solidity",
	"Extent",
	"Perimeter")])

  x<-imcExperiment(cellIntensity=t(expr),
	coordinates=spatial,
	neighborHood=as.matrix(pre[,grepl("neighbour_",colnames(pre))]),
	network=phenotypes,
	distance=matrix(1,nrow=nrow(pre),ncol=10),
	morphology=morph,
	panel=colnames(normExp),
	uniqueLabel=uniqueLabel,
	ROIID=data.frame(ROIID=pre$ROIID))

   x
   colnames(x)<-getLabel(x)
  
   assays(x,withDimnames=FALSE)<-SimpleList(counts=t(expr),scaledCounts=t(normExp))
      
   cellData<-DataFrame(pre[,c("ROIID","uniqueLabel","Patient.Number","condition","batch","Age","Cytogenetics","TMA")])
   cellData$condition[is.na(cellData$condition)]<-"PRE"
   colData(x)<-cellData
   head(colData(x))
   marker_info<-data.frame(channel_name=sapply(strsplit(rownames(x),"_"),function(x) x[3]),
              marker_name=rownames(x),
              marker_class=c(rep("type",length(lineage)),
                             rep("state",length(induc)),
                             rep("none",length(background))))
   
   
   
#load the clinical sheet
    fpath <- system.file("extdata", "key.csv", package="imcExperiment")
    key<-read.csv(fpath)
    metadata(x)<-list(experiment_info=key)

   
   
```


### IMC Transition Into SummarizedExperiment Class
- cast IMC experiment into Summarized class to inherit CyTOF libraries such as **flowCore**.
- the expression slot contains the raw intensity, we use the **transform()** function to apply the inverse hyperbolic sine transformation with cofactor of 5.
- construct singleCellExperiment class and create a heatmap visual uses scaled intensity
- inherit the visualization and exploratory tools from CATALYST(CITE) or other CyTOF based libraries developed over the SingleCellExperiment class.

```{r}

library(CATALYST)
library(flowCore)
library(SingleCellExperiment)
library(diffcyt)

 ## from IMCexperiment to SCE

   ## Switching into Summarized Experiment class.
    dse<-SummarizedExperiment(assays=SimpleList(exprs=t(cellIntensity(x))),
                           rowData=colData(x),
                           colData=DataFrame(marker_info)
                           )
   stopifnot(all(colnames(dse)==marker_info$marker_name))
   dse
 rownames(dse)<-rowData(dse)$uniqueLabel
 # Transform data recommended
 dse <- transformData(dse)
## maybe look a the normalization.
# Generate clusters
dse <- (generateClusters(dse,meta_clustering=TRUE,meta_k=30,seed_clustering=828))

 ## examine each cluster.
cluster<-rowData(dse)


##construct singleCellExperiment
  sce<-SingleCellExperiment(x)
  
  
   metadata(sce)<-metadata(x)
   
   rowData(sce)<-marker_info
  colData(sce)<-colData(x)
    colData(sce)$sample_id<-colData(sce)$ROIID
  
  
  ###store min/max normalized counts under 'counts' slot.
 
  
   assays(sce, withDimnames = FALSE)<-SimpleList(exprs=cellIntensity(x)[rownames(x),],
                                                 counts=assays(x)$counts,
                                                 scaledCounts=assays(x)$scaledCounts[rownames(x),]
                                                 )
 
  sce<-transformData(sce)
  ##raw counts
  dim(counts(sce))
  ## min/max counts
   ##SOM clustering
   sce <- cluster(sce) 
   
   pca_data <- prcomp(t(assays(sce)$exprs), rank=50)
 
##added the reduced dimensions PCA data.
reducedDims(sce) <- list(PCA=pca_data$x)
sce
   
   
 plotPbExprs(sce,k="meta15",group_by="cluster_id",color_by="condition")
   plotClusterExprs(sce, k = "meta20", features = "type")
   
# access specific clustering resolution
table(cluster_ids(sce))

plotAbundances(sce, k = "meta20", by = "sample_id", group_by = "condition")

plotExprHeatmap(sce, features = "type",
    by = "cluster_id", k = "meta20",
    scale = "first", q = 0.01, perc = TRUE, col_dend = FALSE)

plotMultiHeatmap(sce, 
    hm1 = "type", hm2 = "state", 
    k = "meta20", 
    col_dend = c(FALSE, TRUE))   
  
  

``` 



### IMC container and Phenograph cluster neighborhood 
- Phenograph an IMC contrainer and heatmap result.
- alternative clustering method.
```{r pheno,eval=FALSE,fig.width=11,fig.height=11,message=FALSE}

 ### create  phenotypes via Rphenograph
 batch12<-metadata(x)$experiment_info[which(metadata(x)$experiment_info[,"batch"]%in%c("batch1","batch2")),"ROIID"]
 library(igraph)
x12<-selectCases(x,batch12 )
  expr<-t(assays(x12)$counts)
  normExp<-percentilenormalize(data=expr,percentile=0.99)
  normExp<-as.matrix(normExp)
assays(x12)$scaledCounts<-t(normExp)
   x12<-metaClusterIMC(imc=x12,markers=lineage,plotPCA=FALSE,k2=15,assay="scaledCounts")

   
   
   sce<-SingleCellExperiment(x12)
   metadata(sce)<-metadata(x12)
   rowData(sce)<-marker_info
  colData(sce)<-colData(x12)
    colData(sce)$sample_id<-colData(sce)$ROIID
    ###store min/max normalized counts under 'counts' slot.
    assays(sce, withDimnames = FALSE)<-SimpleList(exprs=cellIntensity(x12)[rownames(x12),],
                                                 counts=assays(x12)$counts,
                                                 scaledCounts=assays(x12)$scaledCounts[rownames(x12),]
                                                 )
 
  sce<-transformData(sce)
  ##raw counts
  dim(counts(sce))
  ## min/max counts
   ##SOM clustering
   sce <- cluster(sce) 
   
   
    ##plot the meta-cluster ID
   metadata(sce)$cluster_codes<-data.frame(custom=factor(unique(getNetwork(x12)[,2])) ) 

  
   
  plotExprHeatmap(sce, features = "type",
    by = "cluster_id", k = "custom", fun="mean",
    scale = "first", q = 0.01, perc = TRUE, col_dend = FALSE)


 
```


## IMC Transition Into flowSet Class
* utilize CATALYST package for IMC we can see scatter plots after converting to FlowSets.
* the rownames for IMC are set to the panel names, and we can split these to create the marker and metal.
* The ROIID is useful for quickly creating a FlowSet object as a class inheritance method.
* The rownames of IMC container are usually in "Cell_Marker_ChannelMetal"
```{r, eval=FALSE,message=FALSE}


   ## the assay returns matrix class! required for CATALYST.
  is(assay(x,'counts'),'matrix')
  rownames(x)
    # for plot scatter to work need to set the rowData feature in a specific way.
   channel<-sapply(strsplit(rownames(x),"_"),function(x) x[3])

   marker<-sapply(strsplit(rownames(x),"_"),function(x) x[2])
    rowData(x)<-DataFrame(channel_name=channel,marker_name=marker)
      rownames(x)<-marker
            plotScatter(x,rownames(x)[9:12],assay='scaledCounts')

  # convert to flowSet
             ## the warning has to do with duplicated Iridium channels.
   table(colData(x)$ROIID)
       (fsimc <- sce2fcs(x, split_by = "ROIID",assay="scaledCounts"))
    ## now we have a flowSet.
   pData(fsimc)
   fsApply(fsimc,nrow)
   dim(exprs(fsimc[[1]]))
   exprs(fsimc[[1]])[1:5,1:5]
    ## set up the metadata files.
   head(marker_info)
   
    exper_info<-data.frame(group_id=colData(x)$condition[match(pData(fsimc)$name,colData(x)$ROIID)],
                           patient_id=colData(x)$Patient.Number[match(pData(fsimc)$name,colData(x)$ROIID)],
                           sample_id=pData(fsimc)$name)
   
   ## create design
   design<-createDesignMatrix(
     exper_info,cols_design=c("group_id","patient_id"))
   
   ##set up contrast 
   contrast<-createContrast(c(0,1,0))
   nrow(contrast)==ncol(design)
   data.frame(parameters=colnames(design),contrast)
   
    ## flowSet to DiffCyt
    out_DA<-diffcyt(
      d_input=fsimc,
      experiment_info=exper_info,
      method_DA="diffcyt-DA-edgeR",
      marker_info=marker_info,
      design=design,
      contrast=contrast,
      analysis_type = "DA",
      seed_clustering = 123
    )
   topTable(out_DA,format_vals = TRUE,show_logFC = TRUE)
   
   out_DS<-diffcyt(
     d_input=fsimc,
     experiment_info=exper_info,
     marker_info=marker_info,
     design=design,
     contrast=contrast,
     analysis_type='DS',
     seed_clustering = 123,
     plot=TRUE)
   
      topTable(out_DS,format_vals = TRUE,show_logFC = TRUE)
      
       ### from flowSet to SE.
 d_se<-prepareData(fsimc,exper_info,marker_info)



```




## Accessors, and setters {.tabset}
* the cellIntensity() function accesses cell Intensity
* getCoordinates() accesses spatial data.
* getNeighborhood() access the histoCAT neighborhood features
* getDistance() accesses distance matrix input.
* getMorphology() accesses morphology features.
* the metadata() function can store extras .
```{r access,eval=TRUE,message=FALSE}

  #get cellintensities
  head(t(cellIntensity(x)))
  #set intensities
 

 ## access the coordinates
  head(  getCoordinates(x))
  
 ## access the neighborhood profile.  Note each row must equal the number of cells, but the columns can be extended depending on the radius of interactions.
  ## access the coordinates
  head( getNeighborhood(x))

 ## get the distance usually a square matrix, or can be just first nearest etc. 
    head(getDistance(x))

 # get morphological features
   head(getMorphology(x))

 ## for each cell we can obtain the ROI that it belongs to
  rowData(x)
 ## if we want to add patient features to each ROI we can
 
   ##store the ROIID in the metadata columns.
  ##access the unique cell labels.

  tail(getLabel(x))
  
  ##subset an ROI
  
  roi<-subsetCase(x,"ROIID_1" )
  roi
  
   
  rois<-selectCases(x,c("ROIID_1","ROIID_2","ROIID_3" ))
  rois
  
  t(cellIntensity(rois))%>%dim
  getLabel(rois)%>%length
  
```




## PCA and UMAP Analysis {.tabset}
* PCA data and tSNE coordinates can be added to the container.
```{r}
 library(umap)

 ### inherited accessor.
  pca_data <- prcomp(t(counts(x)), rank=50)


reducedDims(x)<-list(PCA=pca_data$x)
x
reducedDimNames(x)
 
```




## Spatial Analysis Using Geographic Information Systems {.tabset}
* The function 'imcExperimentToHyperFrame(), creates a point pattern useful for distance measures.
* Given a hyperframe pairwise computations can be done.

```{r}


  ##you can append more clinical features to the columns of the sampleDat data.frame.
  H<-imcExperimentToHyperFrame(imcExperiment=x,phenotypeToUse = 1)
  helper<-function(pp=NULL,i=NULL,j=NULL){
  ps<-split(pp)
  nnd<-nncross(ps[[i]],ps[[j]])
  }
 ## 1-NN analysis.
  ## compare cluster 10 to cluster 9
   #eachNND<-with(H,helper(pp=point,i="10",j="8"))
 ## first choose 2 clusters to compare.
 # sapply(eachNND,function(x) mean(x[,"dist"]))



```

